	subroutine VMAT2(theta,Kmax,fract,finfo,covar,unit,det,SSD,
     & smin,nfix,jfix,SCAL)
c	subroutine VMAT2(THETA,K,FRACT,FINFO,COVAR,UNIT,DET,ELIK,
c     & ELMAX,NFIX,JFIX)
c
c 12/28/89 03:16pm Lahey version
c General purpose calc of Hessian with up to 20 param
c Returns SCALED values (see HESMAT)
c
C D COLQUHOUN JAN 1977
C***14-JAN-83. VERSION WITH SCALE FACTORS FOR PARAMETERS AS
C SEEMS THAT THERE MAY BE NUMERICAL PROBLEMS IN INVERTING LARGE MATRICES
C WITH ELEMENTS OF WIDELY VARYING SIZE
C***6-NOV-82. VERSION FOR USE WITH FUNCTION ELIK(K,THETA) THAT
C CALCULATES MINUS LIKELIHOOD RATHER THAN SUM OF SQUARES
C***9-OCT-82. VERSION WITH PARAMETER JFIX(KMAX) WITH ELEMENTS SET
C  TO ZERO EXCEPT IF THETA(I) IS FIXED JFIX(I)=1. NFIX=NUMBER OF
C  FIXED VALUES. K=TOTAL NO OF PARAM (INC FIXED).
C  N.B. FINFO ETC ARE RETURNED AS KFIT*KFIT MATRICES (KFIT=K-NFIX) WITH
C  ROW AND COL FOR FIXED PARAM OMITTED
C VERSION WITH OPTIONAL AUTOMATIC CALC OF STEP SIZE FOR DERIVATIVES
C DOUBLE PRECISION VERSION FOR MATRIX OPS
C FINFO,COVAR,UNIT AND DET MUST BE DOUBLE PREC IN CALLING PROGRAM
C ARRAYD,GMPROD AND MINVD ARE DOUBLE PRECISION VERSIONS OF THE
C SSP SUBROUTINES ARRAY,GMPRD AND MINV
c ###NB these are still for 10x10 matrices, but work anyway??
C
	dimension  FINFO(20,20),COVAR(20,20),UNIT(20,20)
	dimension DELTA(20),scal(20)
	REAL*8 FINFO,COVAR,UNIT,DET
	real THETA(20),TH1(20),TH2(20),TH3(20),TH4(20)
	integer LWORK(20),MWORK(20),JFIX(20)
	LOGICAL DEBUG,caplock
c	external ELIK
	external SSD
c
	debug()=caplock()
c NB SSDCV gives -2*log likelihood; in version for EKDIST etc use
c ELIK(=explik etc)=-log likelihood, SSD=2*ELIK, or ELIK=0.5*SSD
C
C  THETA IS THE ARRAY OF K MAXIMUM LIKELIHOOD ESTIMATES.
C  FRACT=FRACTION BY WHICH EACH PARAMETER CHANGED TO FIND DERIVATIVES
C   IF POSITIVE. IF NEGATIVE, VALUE IS IGNORED AND A VALUE CHOSEN BY
C   STARTING WITH A LOW VALUE AND INCREASING IT UNTIL S IS INCREASED
C   BY AT LEAST 1 PERCENT WHEN ITH PARAMETER INCREASED BY FRACT*THETA(I)
C  FINFO=INFORMATION (HESSIAN) MATRIX (OUTPUT)
C  COVAR=VARIANCE-COVARIANCE MATRIX (OUTPUT)
C  UNIT=INFO*COVAR IS CALC AS CHECK ON INVERSION,AS IS DET(INFO).
C THE SUBROUTINE ELIK CALCULATES THE MINUS-LOG-LIKELIHOOD-THE FUNCTION
C PREVIOUSLY
C MINIMIZED,IN FORM ELIK(K,TH) WHERE TH IS AN ARRAY OF PARAMETER VALUES.
C ARGUMENT SUBSTITUTED FOR ELIK MUST BE DECLARED EXTERNAL IN CALLING PROG.
C
	KFIT=Kmax-NFIX
	elmax=-smin/2.
C
C GET SCALE FACTORS FOR THETA, SO ALL VALUES IN RANGE 1-10 IE DIVIDE
C ACTUAL VALUES BY 10**(SCAL) WHERE SCAL=FLOAT(IFIX(ALOG10(THETA)))
C THIS DEFINES SCAL(I),I=1,KFIT FOR UNFIXED PARAM AS NEEDED FOR FINFO
c
	I1=1
	DO 100 I=1,Kmax
	IF(JFIX(I).EQ.1) GOTO 100
	SCAL(I1)=10.0**FLOAT(IFIX(ALOG10(abs(THETA(I)))))
	I1=I1+1
100	CONTINUE
C
C NEXT CALC FINFO WITH UNSCALED VALUES AS BEFORE. THEN SCALE FINFO
C BEFORE INVERSION.
C
      IF(FRACT.LT.0.) GOTO 8
      DO 1 M=1,Kmax
1     DELTA(M)=FRACT*THETA(M)
      GOTO 12
8	CONTINUE
C -ELIK=LOG LIKELIHOOD
c	IF(DEBUG()) print 82,(THETA(I),I=1,Kmax)
c82	FORMAT( ' THETA= ',5G13.6,/,5G13.6)
c	IF(debug()) print 83,-0.5*SSD(Kmax,THETA),(JFIX(I),I=1,Kmax)
c83	FORMAT (' Lmax: calc in VMATD= ',G13.6,/,
c     & ' JFIX= ',20I3)
C	X=0.005		!DEFAULT
C	X=0.5		!DEFAULT
	ELCRIT=ELMAX-0.005*ABS(ELMAX)	!DEFAULT
C	IF(.NOT.debug()) GOTO 13
	x=-1.
	if(fract.lt.0.) goto 13		!use default ELCRIT
	print 81,ELMAX
81	FORMAT( ' Lmax (in VMATD)= ',G13.6)
	print 14
14	FORMAT( ' Lcrit=Lmax-X:   X= ')
	read 15,X
15	FORMAT(G13.6)
	ELCRIT=ELMAX-X
13	CONTINUE
C
c	print 92,ELCRIT
c92	FORMAT(' ELCRIT= ',G13.6)
c
      DO 9 I=1,Kmax
	IF(JFIX(I).EQ.1) GOTO 9
c	print 91,I
cc91	FORMAT(' I= ',I2)
      DO 10 M=1,Kmax
10    TH1(M)=THETA(M)		!RESET TH1 FOR EACH PARAM
      DELTA(I)=0.01*THETA(I)	!START WITH FRACT=0.01
      TH1(I)=THETA(I)+DELTA(I)	!TRY START VALUE
	EL=-0.5*SSD(Kmax,TH1)		! +LOG LIKELIHOOD
c	print 93,EL
c93	FORMAT( ' EL= ',G13.6)
      IF (EL.LT.ELCRIT) GOTO 16	!SECTION TO DEC DELTA
C NEXT BIT DONE IF L STILL >LCRIT I.E. DELTA TOO SMALL TO REDUCE
C L BELOW LCRIT SO INCREASE DELTA
11	DELTA(I)=2.*DELTA(I)	!INCREASE DELTA UNTIL L<ELCRIT
	TH1(I)=THETA(I)+DELTA(I)
	EL=-0.5*SSD(Kmax,TH1)		! +LOG LIKELIHOOD
c	print 94,DELTA(I),EL
c94	FORMAT( ' DELTA,EL= ',2G13.6)
	IF (EL.LT.ELCRIT) GOTO 9	!O.K. NOW:NEXT PARAMETER
	if(delta(i).lt.1.e-20) goto 11	!increase delta more
16	CONTINUE
17      DELTA(I)=0.5*DELTA(I)	!DECREASE DELTA UNTIL L>ELCRIT
	TH1(I)=THETA(I)+DELTA(I)
	EL=-0.5*SSD(Kmax,TH1)		! +LOG LIKELIHOOD
c	print 94,DELTA(I),EL
	IF (EL.GT.ELCRIT) GOTO 9	!OK NOW: NEXT PARAMETER
	GOTO 17		!REDUCE DELTA AGAIN
9     CONTINUE
c
12	continue
	do 182 i=1,kmax
	   if(jfix(i).eq.1) goto 182
	   f=0.
	   if(abs(theta(i)).gt.1.e-21) f=delta(i)/theta(i)
	   print 18,i,delta(i),f
18	   format(' i = ',i4,' delta(i), fract(i) = ',2G13.6)
182	continue
C DELTA NOW SET FOR EACH PARAMETER.
C
C NOW ESTIMATE HESSIAN
	II=0	!INDEX FOR FINFO ETC (=1,2,..,KFIT)
	DO 2 I=1,Kmax
	IF(JFIX(I).EQ.1) GOTO 2		!OMIT ROW OF FINFO IF PARAM FIXED
	II=II+1
	JJ=0
C      DO 3 J=I,Kmax
	DO 3 J=1,I
	IF(JFIX(J).EQ.1) GOTO 3		!OMIT COLUMN
	JJ=JJ+1
C RESET TH1...TH4 EVERY CYCLE
      DO 4 M=1,Kmax
      TH1(M)=THETA(M)
      TH2(M)=THETA(M)
      TH3(M)=THETA(M)
    4 TH4(M)=THETA(M)
C  ALTER APPROPRIATE ELEMENTS OF THETA TO FORM DERIVATIVES
      TH1(I)=TH1(I)+DELTA(I)
      TH3(I)=TH3(I)-DELTA(I)
      IF(I.NE.J) GOTO 5
C  NOW DO DIAGONAL ELEMENTS
      DEN=DELTA(I)**2
      FINFO(II,JJ)=0.5*(SSD(Kmax,TH1)-
     & 2.0*SSD(Kmax,THETA)+
     & SSD(Kmax,TH3))/DEN
      GOTO 6
C   NOW THE OFF DIAGONALS
    5 TH1(J)=TH1(J)+DELTA(J)
      TH2(I)=TH2(I)+DELTA(I)
      TH2(J)=TH2(J)-DELTA(J)
      TH3(J)=TH3(J)+DELTA(J)
      TH4(I)=TH4(I)-DELTA(I)
      TH4(J)=TH4(J)-DELTA(J)
      DEN=4.0*DELTA(I)*DELTA(J)
      FINFO(II,JJ)=0.5*(SSD(Kmax,TH1)-
     & SSD(Kmax,TH2)-SSD(Kmax,TH3)
     & +SSD(Kmax,TH4))/DEN
      FINFO(JJ,II)=FINFO(II,JJ)
    6 CONTINUE
    3 CONTINUE
    2 CONTINUE
C
C NOW SCALE INFO
	DO 101 I=1,KFIT
	DO 101 J=1,KFIT
101	FINFO(I,J)=FINFO(I,J)*SCAL(I)*SCAL(J)
C
C NOW HAVE INFO. BEFORE INVERSION MUST CONVERT TO VECTOR STORAGE
      CALL ARRAYD(2,KFIT,KFIT,20,20,COVAR,FINFO)
C INFO MATRIX NOW IN COVAR, IN ONE DIMENSIONAL FORM,FOR INVERSION
      CALL MINVD(COVAR,KFIT,DET,LWORK,MWORK,ndexp)
C AFTER CALL TO MINV,COVAR NOW CONTAINS INVERSE OF INFO IN VECTOR FORM
C NOW CONVERT FINFO TO VECTOR FORM FOR MULTIPLICATION
      CALL ARRAYD(2,KFIT,KFIT,20,20,FINFO,FINFO)
C NOW MULTIPLY INFO*COVAR. RESULT SHOULD BE UNIT
      CALL GMPROD(FINFO,COVAR,UNIT,KFIT,KFIT,KFIT)
C NOW CONVERT FINFO,COVAR AND UNIT BACK TO MATRIX FORM
      CALL ARRAYD(1,KFIT,KFIT,20,20,FINFO,FINFO)
      CALL ARRAYD(1,KFIT,KFIT,20,20,COVAR,COVAR)
      CALL ARRAYD(1,KFIT,KFIT,20,20,UNIT,UNIT)
C
cC RESCALE FINFO AND COVAR TO ORIGINAL UNITS
c	DO 102 I=1,KFIT
c	DO 102 J=1,KFIT
c	SFAC=SCAL(I)*SCAL(J)
c	FINFO(I,J)=FINFO(I,J)/SFAC
c	COVAR(I,J)=COVAR(I,J)*SFAC
c102	CONTINUE
	RETURN
	end


