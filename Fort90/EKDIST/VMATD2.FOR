	SUBROUTINE VMATD2(THETA,K,FRACT,FINFO,COVAR,UNIT,DET,ELIK,
     & ELMAX,NFIX,JFIX)
c
c 11/13/97 03:56pm Modif throughout for 50 paramters! now calls minvd2
c    theta(50),theta(50,5), jfix(50), titlep(5)
c VMATD2 is version of VMATD which, like VMAT2, has arrays of dimension 20
c rather than 10, but which las likelihood in call (ELIK), rather than
c SSD (as in VMAT2). Calls GMPROD (rather than GMPRDD) accordingly.
c 06/06/89 08:13pm Lahey version
c
C Version for EKDIST
C D COLQUHOUN JAN 1977
C***14-JAN-83. VERSION WITH SCALE FACTORS FOR PARAMETERS AS
C SEEMS THAT THERE MAY BE NUMERICAL PROBLEMS IN INVERTING LARGE MATRICES
C WITH ELEMENTS OF WIDELY VARYING SIZE
C***6-NOV-82. VERSION FOR USE WITH FUNCTION ELIK(K,THETA) THAT
C CALCULATES MINUS LIKELIHOOD RATHER THAN SUM OF SQUARES
C***9-OCT-82. VERSION WITH PARAMETER JFIX(KMAX) WITH ELEMENTS SET
C  TO ZERO EXCEPT IF THETA(I) IS FIXED JFIX(I)=1. NFIX=NUMBER OF
C  FIXED VALUES. K=TOTAL NO OF PARAM (INC FIXED).
C  N.B. FINFO ETC ARE RETURNED AS KFIT*KFIT MATRICES (KFIT=K-NFIX) WITH
C  ROW AND COL FOR FIXED PARAM OMITTED
C VERSION WITH OPTIONAL AUTOMATIC CALC OF STEP SIZE FOR DERIVATIVES
C DOUBLE PRECISION VERSION FOR MATRIX OPS
C FINFO,COVAR,UNIT AND DET MUST BE DOUBLE PREC IN CALLING PROGRAM
C ARRAYD,GMPRDD AND MINVD ARE DOUBLE PRECISION VERSIONS OF THE
C SSP SUBROUTINES ARRAY,GMPRD AND MINV
C
	dimension  FINFO(50,50),COVAR(50,50),UNIT(50,50)
	dimension DELTA(50),scal(50)
	REAL*8 FINFO,COVAR,UNIT,DET
	real THETA(50),TH1(50),TH2(50),TH3(50),TH4(50)
	integer LWORK(50),MWORK(50),JFIX(50)
	LOGICAL DEBUG,caplock
	external ELIK
c
	debug()=caplock()
C
C  THETA IS THE ARRAY OF K MAXIMUM LIKELIHOOD ESTIMATES.
C  FRACT=FRACTION BY WHICH EACH PARAMETER CHANGED TO FIND DERIVATIVES
C   IF POSITIVE. IF NEGATIVE, VALUE IS IGNORED AND A VALUE CHOSEN BY
C   STARTING WITH A LOW VALUE AND INCREASING IT UNTIL S IS INCREASED
C   BY AT LEAST 1 PERCENT WHEN ITH PARAMETER INCREASED BY FRACT*THETA(I)
C  FINFO=INFORMATION (HESSIAN) MATRIX (OUTPUT)
C  COVAR=VARIANCE-COVARIANCE MATRIX (OUTPUT)
C  UNIT=INFO*COVAR IS CALC AS CHECK ON INVERSION,AS IS DET(INFO).
C THE SUBROUTINE ELIK CALCULATES THE MINUS-LOG-LIKELIHOOD-THE FUNCTION
C PREVIOUSLY
C MINIMIZED,IN FORM ELIK(K,TH) WHERE TH IS AN ARRAY OF PARAMETER VALUES.
C ARGUMENT SUBSTITUTED FOR ELIK MUST BE DECLARED EXTERNAL IN CALLING PROG.
C
	KFIT=K-NFIX
C
C GET SCALE FACTORS FOR THETA, SO ALL VALUES IN RANGE 1-10 IE DIVIDE
C ACTUAL VALUES BY 10**(SCAL) WHERE SCAL=FLOAT(IFIX(ALOG10(THETA)))
C THIS DEFINES SCAL(I),I=1,KFIT FOR UNFIXED PARAM AS NEEDED FOR FINFO
c
	I1=1
	DO 100 I=1,K
	IF(JFIX(I).EQ.1) GOTO 100
	SCAL(I1)=10.0**FLOAT(IFIX(ALOG10(THETA(I))))
	I1=I1+1
100	CONTINUE
C
C NEXT CALC FINFO WITH UNSCALED VALUES AS BEFORE. THEN SCALE FINFO
C BEFORE INVERSION.
C
      IF(FRACT.LT.0.) GOTO 8
      DO 1 M=1,K
1     DELTA(M)=FRACT*THETA(M)
      GOTO 12
8	CONTINUE
C -ELIK=LOG LIKELIHOOD
	IF(DEBUG()) print 82,(THETA(I),I=1,K)
82	FORMAT( ' THETA= ',5G13.6,/,5G13.6)
	IF(debug()) print 83,-ELIK(K,THETA),(JFIX(I),I=1,K)
83	FORMAT (' Lmax: calc in VMATD= ',G13.6,/,
     & ' JFIX= ',10I3)
C	X=0.005		!DEFAULT
C	X=0.5		!DEFAULT
c	ELCRIT=ELMAX-0.005*ABS(ELMAX)	!DEFAULT
	ELCRIT=ELMAX-0.002*ABS(ELMAX)	!DEFAULT
C	IF(.NOT.debug()) GOTO 13
	x=-1.
	if(fract.lt.0.) goto 13		!use default ELCRIT
	print 81,ELMAX
81	FORMAT( ' Lmax (in VMATD)= ',G13.6)
	print 14
14	FORMAT( ' Lcrit=Lmax-X:   X= ')
	call INPUTr(x)
15	FORMAT(G13.6)
	ELCRIT=ELMAX-X
13	CONTINUE
C
c	print 92,ELCRIT
c92	FORMAT(' ELCRIT= ',G13.6)
      DO 9 I=1,K
	IF(JFIX(I).EQ.1) GOTO 9
c	print 91,I
cc91	FORMAT(' I= ',I2)
      DO 10 M=1,K
10    TH1(M)=THETA(M)		!RESET TH1 FOR EACH PARAM
      DELTA(I)=0.01*THETA(I)	!START WITH FRACT=0.01
      TH1(I)=THETA(I)+DELTA(I)	!TRY START VALUE
	EL=-ELIK(K,TH1)		! +LOG LIKELIHOOD
c	print 93,EL
c93	FORMAT( ' EL= ',G13.6)
      IF (EL.LT.ELCRIT) GOTO 16	!SECTION TO DEC DELTA
C NEXT BIT DONE IF L STILL >LCRIT I.E. DELTA TOO SMALL TO REDUCE
C L BELOW LCRIT SO INCREASE DELTA
11	DELTA(I)=2.*DELTA(I)	!INCREASE DELTA UNTIL L<ELCRIT
	TH1(I)=THETA(I)+DELTA(I)
	EL=-ELIK(K,TH1)		! +LOG LIKELIHOOD
c	print 94,DELTA(I),EL
c94	FORMAT( ' DELTA,EL= ',2G13.6)
	IF (EL.LT.ELCRIT) GOTO 9	!O.K. NOW:NEXT PARAMETER
	GOTO 11		!INCREASE DELTA MORE
16	CONTINUE
17      DELTA(I)=0.5*DELTA(I)	!DECREASE DELTA UNTIL L>ELCRIT
	TH1(I)=THETA(I)+DELTA(I)
	EL=-ELIK(K,TH1)		! +LOG LIKELIHOOD
c	print 94,DELTA(I),EL
	IF (EL.GT.ELCRIT) GOTO 9	!OK NOW: NEXT PARAMETER
	GOTO 17		!REDUCE DELTA AGAIN
9     CONTINUE
12	print 18,(DELTA(I),I=1,K)
18	FORMAT( ' DELTA(I)= ',/,5G13.6,/,5G13.6)
	print 181,(DELTA(I)/THETA(I),I=1,K)
181	FORMAT( ' FRACT(I)= ',/,5G13.6,/,5G13.6)
C DELTA NOW SET FOR EACH PARAMETER.
C
C NOW ESTIMATE HESSIAN
	II=0	!INDEX FOR FINFO ETC (=1,2,..,KFIT)
	DO 2 I=1,K
	IF(JFIX(I).EQ.1) GOTO 2		!OMIT ROW OF FINFO IF PARAM FIXED
	II=II+1
	JJ=0
C      DO 3 J=I,K
	DO 3 J=1,I
	IF(JFIX(J).EQ.1) GOTO 3		!OMIT COLUMN
	JJ=JJ+1
C RESET TH1...TH4 EVERY CYCLE
      DO 4 M=1,K
      TH1(M)=THETA(M)
      TH2(M)=THETA(M)
      TH3(M)=THETA(M)
    4 TH4(M)=THETA(M)
C  ALTER APPROPRIATE ELEMENTS OF THETA TO FORM DERIVATIVES
      TH1(I)=TH1(I)+DELTA(I)
      TH3(I)=TH3(I)-DELTA(I)
      IF(I.NE.J) GOTO 5
C  NOW DO DIAGONAL ELEMENTS
      DEN=DELTA(I)**2
      FINFO(II,JJ)=(ELIK(K,TH1)-
     & 2.0*ELIK(K,THETA)+
     & ELIK(K,TH3))/DEN
C	FACTOR OF 0.5 NOT NEEDED SINCE ELIK GIVES MINUS LOG-LIK
      GOTO 6
C   NOW THE OFF DIAGONALS
    5 TH1(J)=TH1(J)+DELTA(J)
      TH2(I)=TH2(I)+DELTA(I)
      TH2(J)=TH2(J)-DELTA(J)
      TH3(J)=TH3(J)+DELTA(J)
      TH4(I)=TH4(I)-DELTA(I)
      TH4(J)=TH4(J)-DELTA(J)
      DEN=4.0*DELTA(I)*DELTA(J)
      FINFO(II,JJ)=(ELIK(K,TH1)-
     & ELIK(K,TH2)-ELIK(K,TH3)
     & +ELIK(K,TH4))/DEN
      FINFO(JJ,II)=FINFO(II,JJ)
    6 CONTINUE
    3 CONTINUE
    2 CONTINUE
C
C NOW SCALE INFO
	DO 101 I=1,KFIT
	DO 101 J=1,KFIT
101	FINFO(I,J)=FINFO(I,J)*SCAL(I)*SCAL(J)
C
C NOW HAVE INFO. BEFORE INVERSION MUST CONVERT TO VECTOR STORAGE
      CALL ARRAYD(2,KFIT,KFIT,50,50,COVAR,FINFO)
C INFO MATRIX NOW IN COVAR, IN ONE DIMENSIONAL FORM,FOR INVERSION
      CALL MINVD2(COVAR,KFIT,DET,LWORK,MWORK,ndexp,50,50)
C AFTER CALL TO MINV,COVAR NOW CONTAINS INVERSE OF INFO IN VECTOR FORM
C NOW CONVERT FINFO TO VECTOR FORM FOR MULTIPLICATION
      CALL ARRAYD(2,KFIT,KFIT,50,50,FINFO,FINFO)
C NOW MULTIPLY INFO*COVAR. RESULT SHOULD BE UNIT
      CALL GMPROD(FINFO,COVAR,UNIT,KFIT,KFIT,KFIT)
C NOW CONVERT FINFO,COVAR AND UNIT BACK TO MATRIX FORM
      CALL ARRAYD(1,KFIT,KFIT,50,50,FINFO,FINFO)
      CALL ARRAYD(1,KFIT,KFIT,50,50,COVAR,COVAR)
      CALL ARRAYD(1,KFIT,KFIT,50,50,UNIT,UNIT)
C
C RESCALE FINFO AND COVAR TO ORIGINAL UNITS
	if(debug()) then
	   print 700,(scal(i),i=1,k)
700	   format(10g8.1,/,10g8.1)
	endif
	DO 102 I=1,KFIT
	DO 102 J=1,KFIT
	SFAC=SCAL(I)*SCAL(J)
	FINFO(I,J)=FINFO(I,J)/SFAC
	COVAR(I,J)=COVAR(I,J)*SFAC
102	CONTINUE
	RETURN
	end


